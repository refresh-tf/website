(()=>{"use strict";if(typeof __webpack_require__<"u"){var D=__webpack_require__.e;__webpack_require__.e=function(p){return Promise.resolve(D(p)).catch(e=>{const S=new Event("nuxt:preloadError",{cancelable:!0});throw S.payload=e,window.dispatchEvent(S),e})}}const O=(p,...e)=>postMessage({type:p,payload:e}),z=function(){const p=function(...t){throw new Error(t.join(" "))};globalThis.window===globalThis?p("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):navigator?.storage?.getDirectory||p("This API requires navigator.storage.getDirectory.");const e=Object.create(null);e.verbose=1;const S={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)},A=(t,...s)=>{e.verbose>t&&S[t]("OPFS asyncer:",...s)},h=(...t)=>A(2,...t),x=(...t)=>A(1,...t),g=(...t)=>A(0,...t),E=Object.create(null),I=new Set,F=function(t,s){const n=new URL(t,"file://irrelevant").pathname;return s?n.split("/").filter(o=>!!o):n},T=async function(s,n=!1){const o=F(s,!0),a=o.pop();let i=e.rootDir;for(const r of o)r&&(i=await i.getDirectoryHandle(r,{create:!!n}));return[i,a]},R=async t=>{if(t.syncHandle){h("Closing sync handle for",t.filenameAbs);const s=t.syncHandle;return delete t.syncHandle,delete t.xLock,I.delete(t.fid),s.close()}},H=async t=>{try{await R(t)}catch(s){x("closeSyncHandleNoThrow() ignoring:",s,t)}},Q=async()=>{if(I.size)for(const t of I){const s=E[t];await H(s),h("Auto-unlocked",t,s.filenameAbs)}},_=async t=>{if(t.releaseImplicitLocks&&I.has(t.fid))return H(t)};class b extends Error{constructor(s,...n){super([...n,": "+s.name+":",s.message].join(" "),{cause:s}),this.name="GetSyncHandleError"}}b.convertRc=(t,s)=>{if(t instanceof b){if(t.cause.name==="NoModificationAllowedError"||t.cause.name==="DOMException"&&t.cause.message.indexOf("Access Handles cannot")===0)return e.sq3Codes.SQLITE_BUSY;if(t.cause.name==="NotFoundError")return e.sq3Codes.SQLITE_CANTOPEN}else if(t?.name==="NotFoundError")return e.sq3Codes.SQLITE_CANTOPEN;return s};const m=async(t,s)=>{if(!t.syncHandle){const n=performance.now();h("Acquiring sync handle for",t.filenameAbs);const o=6,a=e.asyncIdleWaitTime*2;let i=1,r=a;for(;;r=a*++i)try{t.syncHandle=await t.fileHandle.createSyncAccessHandle();break}catch(c){if(i===o)throw new b(c,"Error getting sync handle for",s+"().",o,"attempts failed.",t.filenameAbs);x("Error getting sync handle for",s+"(). Waiting",r,"ms and trying again.",t.filenameAbs,c),Atomics.wait(e.sabOPView,e.opIds.retry,0,r)}h("Got",s+"() sync handle for",t.filenameAbs,"in",performance.now()-n,"ms"),t.xLock||(I.add(t.fid),h("Acquired implicit lock for",s+"()",t.fid,t.filenameAbs))}return t.syncHandle},d=(t,s)=>{h(t+"() => notify(",s,")"),Atomics.store(e.sabOPView,e.opIds.rc,s),Atomics.notify(e.sabOPView,e.opIds.rc)},q=function(t,s){s.readOnly&&p(t+"(): File is read-only: "+s.filenameAbs)};let L=!1;const C={"opfs-async-shutdown":async()=>{L=!0,d("opfs-async-shutdown",0)},mkdir:async t=>{let s=0;try{await T(t+"/filepart",!0)}catch(n){e.s11n.storeException(2,n),s=e.sq3Codes.SQLITE_IOERR}d("mkdir",s)},xAccess:async t=>{let s=0;try{const[n,o]=await T(t);await n.getFileHandle(o)}catch(n){e.s11n.storeException(2,n),s=e.sq3Codes.SQLITE_IOERR}d("xAccess",s)},xClose:async function(t){const s="xClose";I.delete(t);const n=E[t];let o=0;if(n){if(delete E[t],await R(n),n.deleteOnClose)try{await n.dirHandle.removeEntry(n.filenamePart)}catch(a){x("Ignoring dirHandle.removeEntry() failure of",n,a)}}else e.s11n.serialize(),o=e.sq3Codes.SQLITE_NOTFOUND;d(s,o)},xDelete:async function(...t){const s=await C.xDeleteNoWait(...t);d("xDelete",s)},xDeleteNoWait:async function(t,s=0,n=!1){let o=0;try{for(;t;){const[a,i]=await T(t,!1);if(!i||(await a.removeEntry(i,{recursive:n}),s!==4660))break;n=!1,t=F(t,!0),t.pop(),t=t.join("/")}}catch(a){e.s11n.storeException(2,a),o=e.sq3Codes.SQLITE_IOERR_DELETE}return o},xFileSize:async function(t){const s=E[t];let n=0;try{const o=await(await m(s,"xFileSize")).getSize();e.s11n.serialize(Number(o))}catch(o){e.s11n.storeException(1,o),n=b.convertRc(o,e.sq3Codes.SQLITE_IOERR)}await _(s),d("xFileSize",n)},xLock:async function(t,s){const n=E[t];let o=0;const a=n.xLock;if(n.xLock=s,!n.syncHandle)try{await m(n,"xLock"),I.delete(t)}catch(i){e.s11n.storeException(1,i),o=b.convertRc(i,e.sq3Codes.SQLITE_IOERR_LOCK),n.xLock=a}d("xLock",o)},xOpen:async function(t,s,n,o){const a="xOpen",i=e.sq3Codes.SQLITE_OPEN_CREATE&n;try{let r,c;try{[r,c]=await T(s,!!i)}catch(f){e.s11n.storeException(1,f),d(a,e.sq3Codes.SQLITE_NOTFOUND);return}if(e.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&o)try{await r.removeEntry(c)}catch{}const y=await r.getFileHandle(c,{create:i}),l=Object.assign(Object.create(null),{fid:t,filenameAbs:s,filenamePart:c,dirHandle:r,fileHandle:y,sabView:e.sabFileBufView,readOnly:!i&&!!(e.sq3Codes.SQLITE_OPEN_READONLY&n),deleteOnClose:!!(e.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&n)});l.releaseImplicitLocks=o&e.opfsFlags.OPFS_UNLOCK_ASAP||e.opfsFlags.defaultUnlockAsap,E[t]=l,d(a,0)}catch(r){g(a,r),e.s11n.storeException(1,r),d(a,e.sq3Codes.SQLITE_IOERR)}},xRead:async function(t,s,n){let o=0,a;const i=E[t];try{a=(await m(i,"xRead")).read(i.sabView.subarray(0,s),{at:Number(n)}),a<s&&(i.sabView.fill(0,a,s),o=e.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(r){g("xRead() failed",r,i),e.s11n.storeException(1,r),o=b.convertRc(r,e.sq3Codes.SQLITE_IOERR_READ)}await _(i),d("xRead",o)},xSync:async function(t,s){const n=E[t];let o=0;if(!n.readOnly&&n.syncHandle)try{await n.syncHandle.flush()}catch(a){e.s11n.storeException(2,a),o=e.sq3Codes.SQLITE_IOERR_FSYNC}d("xSync",o)},xTruncate:async function(t,s){let n=0;const o=E[t];try{q("xTruncate",o),await(await m(o,"xTruncate")).truncate(s)}catch(a){g("xTruncate():",a,o),e.s11n.storeException(2,a),n=b.convertRc(a,e.sq3Codes.SQLITE_IOERR_TRUNCATE)}await _(o),d("xTruncate",n)},xUnlock:async function(t,s){let n=0;const o=E[t];if(o.syncHandle&&e.sq3Codes.SQLITE_LOCK_NONE===s)try{await R(o)}catch(a){e.s11n.storeException(1,a),n=e.sq3Codes.SQLITE_IOERR_UNLOCK}d("xUnlock",n)},xWrite:async function(t,s,n){let o;const a=E[t];try{q("xWrite",a),o=s===(await m(a,"xWrite")).write(a.sabView.subarray(0,s),{at:Number(n)})?0:e.sq3Codes.SQLITE_IOERR_WRITE}catch(i){g("xWrite():",i,a),e.s11n.storeException(1,i),o=b.convertRc(i,e.sq3Codes.SQLITE_IOERR_WRITE)}await _(a),d("xWrite",o)}},V=()=>{if(e.s11n)return e.s11n;const t=new TextDecoder,s=new TextEncoder("utf-8"),n=new Uint8Array(e.sabIO,e.sabS11nOffset,e.sabS11nSize),o=new DataView(e.sabIO,e.sabS11nOffset,e.sabS11nSize);e.s11n=Object.create(null);const a=Object.create(null);a.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},a.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},a.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},a.string={id:4};const i=c=>a[typeof c]||p("Maintenance required: this value type cannot be serialized.",c),r=c=>{switch(c){case a.number.id:return a.number;case a.bigint.id:return a.bigint;case a.boolean.id:return a.boolean;case a.string.id:return a.string;default:p("Invalid type ID:",c)}};return e.s11n.deserialize=function(c=!1){const y=n[0],l=y?[]:null;if(y){const f=[];let u=1,w,k,N;for(w=0;w<y;++w,++u)f.push(r(n[u]));for(w=0;w<y;++w){const P=f[w];P.getter?(N=o[P.getter](u,e.littleEndian),u+=P.size):(k=o.getInt32(u,e.littleEndian),u+=4,N=t.decode(n.slice(u,u+k)),u+=k),l.push(N)}}return c&&(n[0]=0),l},e.s11n.serialize=function(...c){if(c.length){const y=[];let l=0,f=1;for(n[0]=c.length&255;l<c.length;++l,++f)y.push(i(c[l])),n[f]=y[l].id;for(l=0;l<c.length;++l){const u=y[l];if(u.setter)o[u.setter](f,c[l],e.littleEndian),f+=u.size;else{const w=s.encode(c[l]);o.setInt32(f,w.byteLength,e.littleEndian),f+=4,n.set(w,f),f+=w.byteLength}}}else n[0]=0},e.s11n.storeException=e.asyncS11nExceptions?(c,y)=>{c<=e.asyncS11nExceptions&&e.s11n.serialize([y.name,": ",y.message].join(""))}:()=>{},e.s11n},v=async function(){const s=Object.create(null);for(let n of Object.keys(e.opIds)){const o=C[n];if(!o)continue;const a=Object.create(null);s[e.opIds[n]]=a,a.key=n,a.f=o}for(;!L;)try{if(Atomics.wait(e.sabOPView,e.opIds.whichOp,0,e.asyncIdleWaitTime)!=="not-equal"){await Q();continue}const n=Atomics.load(e.sabOPView,e.opIds.whichOp);Atomics.store(e.sabOPView,e.opIds.whichOp,0);const o=s[n]??p("No waitLoop handler for whichOp #",n),a=e.s11n.deserialize(!0)||[];o.f?await o.f(...a):g("Missing callback for opId",n)}catch(n){g("in waitLoop():",n)}};navigator.storage.getDirectory().then(function(t){e.rootDir=t,globalThis.onmessage=function({data:s}){switch(s.type){case"opfs-async-init":{const n=s.args;for(const o in n)e[o]=n[o];e.verbose=n.verbose??1,e.sabOPView=new Int32Array(e.sabOP),e.sabFileBufView=new Uint8Array(e.sabIO,0,e.fileBufferSize),e.sabS11nView=new Uint8Array(e.sabIO,e.sabS11nOffset,e.sabS11nSize),Object.keys(C).forEach(o=>{Number.isFinite(e.opIds[o])||p("Maintenance required: missing state.opIds[",o,"]")}),V(),h("init state",e),O("opfs-async-inited"),v();break}case"opfs-async-restart":L&&(x("Restarting after opfs-async-shutdown. Might or might not work."),L=!1,v());break}},O("opfs-async-loaded")}).catch(t=>g("error initializing OPFS asyncer:",t))};globalThis.SharedArrayBuffer?globalThis.Atomics?!globalThis.FileSystemHandle||!globalThis.FileSystemDirectoryHandle||!globalThis.FileSystemFileHandle||!globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle||!navigator?.storage?.getDirectory?O("opfs-unavailable","Missing required OPFS APIs."):z():O("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):O("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.")})();
